module Cardano.Plutus.Sort where

import PlutusTx.Prelude
import PlutusTx
import PlutusTx.List
import Control.Arrow ((&&&))
import GHC.Prim (seq)
import Cardano.Plutus.List

-- |
-- > comparing p x y = compare (p x) (p y)
--
-- Useful combinator for use in conjunction with the @xxxBy@ family
-- of functions from "Data.List", for example:
--
-- >   ... sortBy (comparing fst) ...
{-# INLINABLE comparing #-}
comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
comparing p x y = compare (p x) (p y)

{-# INLINABLE monoidSortAssocsWith #-}
monoidSortAssocsWith :: (Monoid b, Ord k) => (a -> k) -> (a -> b) -> [a] -> [(k, b)]
monoidSortAssocsWith key val = monoidSortAssocs . map (key &&& val)


-- | Sort the list, agregating duplicates with the monoid and
-- ordering the elements by the items generated by the
-- argument function.
{-# INLINABLE monoidSortWith #-}
monoidSortWith :: (Monoid b, Ord k) => (a -> k) -> (a -> b) -> [a] -> [b]
-- monoidSortWith key val list = groupSortBy (comparing . key)
monoidSortWith key val = groupSortOn key $ const $ _monoidGroupWith val

-- Helper
{-# INLINABLE _monoidGroupWith #-}
_monoidGroupWith :: Monoid b => (a -> b) -> a -> [a] -> b
_monoidGroupWith val x xs = val x <> mconcat (map val xs)



-- ====================
-- https://hackage.haskell.org/package/sort-1.0.0.0/docs/src/Data-Sort.html

-- | Sort the list of associations, aggregating duplicates with the
-- monoid.
{-# INLINABLE monoidSortAssocs #-}
monoidSortAssocs :: (Monoid a,Ord k)
                 => [(k,a)]
                 -> [(k,a)]
monoidSortAssocs = monoidSortAssocsBy compare

-- | Sort the list of associations, aggregating duplicates with the
-- monoid and ordering the keys with the argument compare function.
{-# INLINABLE monoidSortAssocsBy #-}
monoidSortAssocsBy :: (Monoid a)
                   => (k->k->Ordering)
                   -> [(k,a)]
                   -> [(k,a)]
monoidSortAssocsBy cmp = groupSortAssocsBy cmp $ const monoid_group

-- | Sort the list of associations, aggregating duplicates with the
-- supplied function.
{-# INLINABLE groupSortAssocs #-}
groupSortAssocs :: Ord k
                => (k->a->[a]->b)
                -> [(k,a)]
                -> [(k,b)]
groupSortAssocs = groupSortAssocsBy compare

-- | Sort the list of associations, aggregating duplicates with the
-- supplied function and ordering the keys with the argument
-- compare function.
{-# INLINABLE groupSortAssocsBy #-}
groupSortAssocsBy :: (k->k->Ordering)
                  -> (k->a->[a]->b)
                  -> [(k,a)]
                  -> [(k,b)]
groupSortAssocsBy cmp0 grp0 = groupSortBy cmp grp
  where
    cmp (k,_) (k',_) = cmp0 k k'

    grp (k,y) ps     = (,) k $ grp0 k y $ map snd ps


-- | Sort the list, agregating duplicates with the monoid.
{-# INLINABLE monoidSort #-}
monoidSort :: (Monoid a,Ord a) => [a] -> [a]
monoidSort = monoidSortBy compare

-- | Sort the list, agregating duplicates with the monoid and
-- ordering the elements by the items generated by the
-- argument function.
{-# INLINABLE monoidSortOn #-}
monoidSortOn :: (Monoid a,Ord k) => (a->k) -> [a] -> [a]
monoidSortOn chg = groupSortOn chg $ const monoid_group

-- | Sort the list, agregating duplicates with the monoid
-- and ordering the keys with the argument compare function.
{-# INLINABLE monoidSortBy #-}
monoidSortBy :: Monoid a => (a->a->Ordering) -> [a] -> [a]
monoidSortBy cmp = groupSortBy cmp monoid_group


-- | Sort the list, discarding duplicates.
{-# INLINABLE uniqueSort #-}
uniqueSort :: Ord a => [a] -> [a]
uniqueSort = uniqueSortBy compare

-- | Sort the list, discarding duplicates and
-- ordering the elements by the items generated by the
-- argument function.
{-# INLINABLE uniqueSortOn #-}
uniqueSortOn :: Ord k => (a->k) -> [a] -> [a]
uniqueSortOn chg = groupSortOn chg $ const const

-- | Sort the list, discarding duplicates and ordering the keys with
-- the argument compare function.
{-# INLINABLE uniqueSortBy #-}
uniqueSortBy :: (a->a->Ordering) -> [a] -> [a]
uniqueSortBy cmp = groupSortBy cmp const


-- | Sort a list of elements with a stable sort, grouping together the
-- equal elements with the argument grouping function
{-# INLINABLE groupSort #-}
groupSort :: (Ord a) => (a->[a]->b) -> [a] -> [b]
groupSort = groupSortBy compare

-- | Sort a list of elements with a stable sort, using the argument
-- @compare@ function determine the ordering, grouping together the
-- equal elements with the grouping function
{-# INLINABLE groupSortOn #-}
groupSortOn :: Ord k
            => (a->k)
            -> (k->a->[a]->b)
            -> [a]
            -> [b]
groupSortOn chg grp = groupSortBy (comparing fst) grp_val . map inj
  where
    grp_val a as = grp k (snd a) $ map snd as
      where
        k = fst a

    inj x = k `seq` (k,x)
      where
        k = chg x


-- | Sort a list of elements with a stable sort, grouping together the
-- equal elements with the argument grouping function.
{-# INLINABLE groupSortBy #-}
groupSortBy :: (a->a->Ordering)
            -> (a->[a]->b)
            -> [a]
            -> [b]
groupSortBy cmp grp = aggregate . sortBy cmp
  where
    aggregate []    = []
    aggregate (h:t) = seq g $ g : aggregate rst
      where
        g         = grp h eqs
        (eqs,rst) = span is_le t

        is_le x   = case cmp x h of
          LT -> True
          EQ -> True
          GT -> False


-- the monoid_group helper

{-# INLINABLE monoid_group #-}
monoid_group :: Monoid a => a -> [a] -> a
monoid_group x xs = x <> mconcat xs
